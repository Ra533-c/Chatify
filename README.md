# üí¨ Chatify - Real-Time Chat Application

A modern, real-time chat application built with the MERN stack (MongoDB, Express, React, Node.js) and Socket.IO. This project features secure user authentication with JWT and Google OAuth 2.0, real-time messaging, online user status, and a sleek, responsive user interface.

![Chatify Banner](https://img.shields.io/badge/MERN-Stack-blue) ![Socket.IO](https://img.shields.io/badge/Socket.IO-Real--Time-green) ![Redux](https://img.shields.io/badge/Redux-State%20Management-purple)

---

## ‚ú® Features

- **Real-Time Messaging**: Instant message delivery using Socket.IO.
- **Online Presence**: See which users are currently online.
- **Secure Authentication**: Robust local signup/login using JWT and http-only cookies.
- **Google OAuth 2.0**: Seamless one-click login and registration with a Google account.
- **State Hydration**: A sophisticated auth-loading flow that persists user sessions correctly in a React SPA.
- **Dynamic Avatars**: Unique, gender-specific user avatars automatically generated by the [DiceBear API](https://www.dicebear.com/).
- **Responsive UI**: A clean and modern user interface built with TailwindCSS that works on all device sizes.
- **Protected Routes**: Frontend routes are protected to ensure only authenticated users can access them.

---

## üõ†Ô∏è Tech Stack

### Frontend
- **React**: UI library
- **React Router**: Declarative routing
- **Redux Toolkit**: State management
- **Axios**: Promise-based HTTP client
- **Socket.IO Client**: Real-time communication
- **TailwindCSS**: Utility-first CSS framework
- **Vite**: Next-generation frontend tooling

### Backend
- **Node.js & Express.js**: Server environment and framework
- **MongoDB & Mongoose**: Database and Object Data Modeling (ODM)
- **Socket.IO**: Real-time WebSocket server
- **JSON Web Token (JWT)**: Secure token-based authentication
- **Passport.js (passport-google-oauth20)**: Google OAuth strategy
- **Bcrypt.js**: Password hashing
- **Dotenv**: Environment variable management

---

## üöÄ Installation and Setup

Follow these instructions to get the project running on your local machine.

### 1. Prerequisites
- **Node.js** (v18 or higher)
- **npm** (v8 or higher)
- **Git**
- A **MongoDB Atlas** account or a local MongoDB instance.
- A **Google Cloud Platform** project with OAuth 2.0 credentials enabled.

### 2. Clone the Repository
```bash
git clone https://github.com/YOUR_USERNAME/YOUR_REPOSITORY.git
cd YOUR_REPOSITORY
```

### 3. Backend Setup
Navigate to the backend directory, install dependencies, and set up your environment variables.

```bash
cd backend
npm install
```

Create a `.env` file in the `backend` directory:
```bash
touch .env
```

Add the following variables to `backend/.env`. **Remember to replace the placeholder values with your actual credentials.**

```env
# Server Port
PORT=3000

# MongoDB Connection String (use the +srv URI from Atlas)
MONGO_URI=your_mongodb_connection_string

# JWT Secret for signing tokens
JWT_SECRET_KEY=your_super_secret_jwt_key

# Google OAuth 2.0 Credentials
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# Frontend URL (for redirects)
FRONTEND_URL=http://localhost:5173
```

### 4. Frontend Setup
In a new terminal, navigate to the frontend directory and install dependencies.

```bash
cd frontend
npm install
```
The frontend does not require its own `.env` file.

### 5. Running the Application
You need two terminals running concurrently.

**Terminal 1: Start the Backend Server**
```bash
cd backend
npm run dev
```
The backend will be running at `http://localhost:3000`.

**Terminal 2: Start the Frontend Development Server**
```bash
cd frontend
npm run dev
```
The frontend will be running at `http://localhost:5173`. Open this URL in your browser.

---

## üèõÔ∏è Architecture Deep Dive: The Authentication Flow

This project uses a robust, secure, and modern authentication system. Here‚Äôs a deep dive into how it works, especially for the Google OAuth flow and how we solve the classic "redirect loop" problem in Single-Page Applications (SPAs).

### Part 1: Google OAuth Redirect Flow

The login process does **not** use a simple `fetch` request. It uses a full-page redirect flow, which is more secure and reliable for OAuth.

1.  **User Clicks "Continue with Google"**: In the `Login.jsx` component, an `onClick` handler triggers `window.location.href = 'http://localhost:3000/api/v1/user/auth/google'`. This causes a full-page navigation to our backend's Google auth endpoint.

2.  **Backend Initiates OAuth**: The backend route, protected by the `passport.authenticate('google', ...)` middleware, receives the request. It immediately constructs a unique URL and redirects the user to Google's login page.

3.  **Google Authenticates User**: The user logs into their Google account and grants permission.

4.  **Google Redirects to Backend Callback**: Google redirects the user back to the `callbackURL` specified in our `passport.js` configuration (`/api/v1/user/auth/google/callback`). This request includes a special `code`.

5.  **Backend Verifies and Creates Session**:
    -   Passport receives the `code`, exchanges it with Google for the user's profile information behind the scenes.
    -   The callback function in `passport.js` runs. It checks if the user exists in our database. If not, it creates a new user.
    -   A **JWT token** is created containing the user's ID.
    -   This token is set as an **`http-only` cookie** in the user's browser. This is a critical security measure that prevents the token from being accessed by client-side JavaScript.
    -   Finally, the backend sends a `302 Found` redirect response, telling the browser to navigate to the frontend's chat page (`res.redirect(process.env.FRONTEND_URL + '/chat')`).

### Part 2: Solving the SPA Redirect Problem (State Hydration)

After the final redirect, a classic problem arises: the React app loads from scratch. Its Redux store is empty, so `authUser` is `null`.

The `<ProtectedRoute>` component sees that `authUser` is `null` and immediately redirects the user back to the `/login` page, creating an infinite loop.

We solve this with a **state hydration** flow:

1.  **`useGetMe` Hook**: We created a custom hook, `useGetMe`, which runs automatically when the main `App.jsx` component first mounts.

2.  **Initial Loading State**: `App.jsx` uses this hook to get a `loading` status. While `loading` is `true`, it displays a simple "Loading..." message and does **not** render the main application router (`<RouterProvider>`).

3.  **Fetching the User**:
    -   The `useGetMe` hook sends a `GET` request to a new backend endpoint: `/api/v1/user/me`.
    -   Crucially, this request is sent with `{ withCredentials: true }`, which includes the `http-only` token cookie that was set during login.
    -   The backend's `/me` endpoint uses the `isAuthenticated` middleware to verify the JWT from the cookie and return the logged-in user's profile data.

4.  **Hydrating the State**:
    -   When the frontend receives the user data, `useGetMe` uses `dispatch(setAuthUser(user))` to populate the Redux store.
    -   The `loading` state in the hook becomes `false`.

5.  **Rendering the App**: The `App` component re-renders. `loading` is now false, so it renders the `<RouterProvider>`. Now, when `<ProtectedRoute>` checks for `authUser`, it finds the user data in the Redux store and grants access to the `/chat` page.

This flow ensures the application always waits to verify the user's session before rendering any protected content, providing a seamless and secure user experience.

---

## ü§ù Contributing

Contributions are welcome! If you have suggestions or want to add new features, please fork the repository and open a pull request.

1.  Fork the Project
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4.  Push to the Branch (`git push origin feature/AmazingFeature`)
5.  Open a Pull Request

---

## üìù License

This project is licensed under the MIT License. See the `LICENSE` file for details.

---

**‚≠ê Star this repository if you find it helpful! ‚≠ê**